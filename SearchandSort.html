<!DOCTYPE HTML>

<html>
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">
		<div id="page-wrapper">

			<!-- Header -->
				<header id="header">
					<h1 id="logo"><a href="index.html">Portfolio</a></h1>
					<nav id="nav">
						<ul>
							<li><a href="index.html">Home</a></li>
							<li>
								<a href="#">Java Topics</a>
								<ul>
									<li><a href="OOP.html">OOP</a></li>
									<li><a href="ArrayArrayList.html">Array/ArrayList</a></li>
									<li><a href="SearchandSort.html">Search and Sort</a></li>
								</ul>
							</li>
							<li>
								<a href="#">Projects</a>
								<ul>
									<li>
										<a href="#">Past Projects</a>
											<ul>
												<li><a href="PastProjects.html">Movie Theatre</a></li>
												<li><a href="PastProjects2.html">Math Tutor</a></li>
											</ul>
									</li>
									<li><a href="CurrentProjects.html">Current/Final Project</a></li>
									<li><a href="FutureProjects.html">Future Projects</a></li>
									
								</ul>
                                                        </li>
							<li></li>
						</ul>
					</nav>
				</header>

			<!-- Main -->
				<div id="main" class="wrapper style1">
					<div class="container">
						<header class="major">
							<h2>Search and Sort Algorithms</h2>
							<p>A faster and more efficient ways to sort and search</p>
						</header>

						<!-- Content -->
							<section id="content">
								<h3>Searching</h3>
								<p>Searching algorithms are used to find a specific value within an array. Looping through the entire array to find a single value is possible, however slow and inefficient.</p>
								<h4>Binary Search</h4>
								<p>Binary search is a recursve algorithm that calls itself until the element is found. Binary search requires the array to be sorted before hand. You take the middle element and you compare whether it is smaller or larger than the value you would like. If the middle element is too small, then you take the top half of the array and start from the middle again, and if the middle value is too low then vice versa.</p>
								<a href="#" class="image medium"><img src="images/binarySearch.png" alt="" /></a>
<pre><code>
int binarySearch(int arr[], int l, int r, int x) { 
        if (r >= l) { 
            int mid = l + (r - l) / 2; 
  
            // If the element is present at the 
            // middle itself 
            if (arr[mid] == x) 
                return mid; 
  
            // If element is smaller than mid, then 
            // it can only be present in left subarray 
            if (arr[mid] > x) 
                return binarySearch(arr, l, mid - 1, x); 
  
            // Else the element can only be present 
            // in right subarray 
            return binarySearch(arr, mid + 1, r, x); 
        } 
    } 
} 
</code></pre>
								<ul class="actions">
									<li><a href="https://www.geeksforgeeks.org/binary-search/" class="button">Learn More</a></li>
								</ul>
								<h3>Sorting</h3>
								<p>Sorting algorithms sort the values of an array in either ascending or descending order</p>
								<h4>Selection Sort</h4>
								<p>This is a search and swap algorithm. First find the smallest element in the whole array and swap it with the value at index 0. Now the smallest element is the first value. Next repeat this step however with the array shrunken to from index 1 to the end then index 2 etc... until the array shrinks to one element.</p>
								<a href="#" class="image medium"><img src="images/selectionSort.png" alt="" /></a>
<pre><code>
int n = arr.length; 
  
// One by one move boundary of unsorted subarray 
for (int i = 0; i < n-1; i++) { 
	// Find the minimum element in unsorted array 
        int min_idx = i; 
        for (int j = i+1; j < n; j++){
        	if (arr[j] < arr[min_idx]) 
                    min_idx = j; 
        }
        // Swap the found minimum element with the first 
        // element 
        int temp = arr[min_idx]; 
        arr[min_idx] = arr[i]; 
        arr[i] = temp; 
} 

</code></pre>							
								<ul class="actions">
									<li><a href="https://www.geeksforgeeks.org/selection-sort/" class="button">Learn More</a></li>
								</ul>
								<h4>Insertion Sort</h4>	
								<p>For insertion sort, think of an array having two subarrays, the first half that is sorted and the second half that is waiting to be sorted. At the beginning of the algorithm, the first element is the sorted array and everything else is the unsorted array. The first step is to take the 1st element of the unsorted array and compare it to the sorted array to determine its position, for the second step take the 2nd element etc...</p>
								<a href="#" class="image small"><img src="images/insertionSort.png" alt="" /></a>
<pre><code>
int n = arr.length; 
for (int i = 1; i < n; ++i) { 
	int key = arr[i]; 
        int j = i - 1; 
  
        /* Move elements of arr[0..i-1], that are greater than key, to one position ahead of their current position */
        while (j >= 0 && arr[j] > key) { 
        	arr[j + 1] = arr[j]; 
                j = j - 1; 
        } 
        arr[j + 1] = key; 
} 
</code></pre>									
								<ul class="actions">
									<li><a href="https://www.geeksforgeeks.org/insertion-sort/" class="button">Learn More</a></li>
								</ul>
								<h4>Merge Sort</h4>	
								<p>Merge sort is also a recursvie algorithm like binary search</p>	
								<p>Steps</p>
								<ul>
									<li>Break the array into two halves</li>
									<li>Mergesort the left half</li>
									<li>Mergesort the right half</li>
									<li>Merge the two subarrays into a sorted array</li>
								</ul>
								<a href="#" class="image small"><img src="images/mergeSort.png" alt="" /></a>
<pre><code>
merge(int arr[], int l, int m, int r) { 
        // Find sizes of two subarrays to be merged 
        int n1 = m - l + 1; 
        int n2 = r - m; 
  
        /* Create temp arrays */
        int L[] = new int[n1]; 
        int R[] = new int[n2]; 
  
        /*Copy data to temp arrays*/
        for (int i = 0; i < n1; ++i) 
            L[i] = arr[l + i]; 
        for (int j = 0; j < n2; ++j) 
            R[j] = arr[m + 1 + j]; 
  
        /* Merge the temp arrays */
        // Initial indexes of first and second subarrays 
        int i = 0, j = 0; 
  
        // Initial index of merged subarry array 
        int k = l; 
        while (i < n1 && j < n2) { 
            if (L[i] <= R[j]) { 
                arr[k] = L[i]; 
                i++; 
            } 
            else { 
                arr[k] = R[j]; 
                j++; 
            } 
            k++; 
        } 
  
        /* Copy remaining elements of L[] if any */
        while (i < n1) { 
            arr[k] = L[i]; 
            i++; 
            k++; 
        } 
  
        /* Copy remaining elements of R[] if any */
        while (j < n2) { 
            arr[k] = R[j]; 
            j++; 
            k++; 
} 
</code></pre>	
								<ul class="actions">
									<li><a href="https://www.geeksforgeeks.org/merge-sort/" class="button">Learn More</a></li>
								</ul>
								<h4>Quicksort</h4>	
								<p>Quicksort is also recursive however it is the opposite of merge sort </p>	
								<p>Steps</p>
								<ul>
									<li>Choose a pivot point</li>
									<li>If value on right is smaller than pivot point move to left and vice versa</li>
									<li>Quicksort the right side of pivot point</li>
									<li>Quicksort the left side of the pivot point</li>
								</ul>
<pre><code>
//Pseudocode
Def QuickSort(array, low, high)
	If low >= high: 
		return
	Pivot = array[high]
	leftPointer = low
	For rightPointer in range(low to high)
		If array[rightPointer] < pivot
			Swap array[leftPointer] and array[rightPointer]
			Leftpointer ++
	Swap array[high] and array[leftPointer]
	QuickSort(array, low, leftPointer-1)
	QuickSort(array, leftPointer+1, high)

</code></pre>	
								<ul class="actions">
									<li><a href="https://www.geeksforgeeks.org/quick-sort/" class="button">Learn More</a></li>
								</ul>
							</section>

					</div>
				</div>

			

		</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/jquery.dropotron.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>